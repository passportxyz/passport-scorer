use sqlx::{PgPool, Postgres, Transaction};
use crate::db::errors::DatabaseError;

/// Get passport by address and scorer_id
pub async fn get_passport(
    _pool: &PgPool,
    _address: &str,
    _scorer_id: i64,
) -> Result<Option<i64>, DatabaseError> {
    // TODO: Implement after SQLX prepare
    // let result = sqlx::query!(
    //     r#"
    //     SELECT id FROM registry_passport
    //     WHERE address = $1 AND community_id = $2
    //     "#,
    //     address,
    //     scorer_id
    // )
    // .fetch_optional(pool)
    // .await?;
    //
    // Ok(result.map(|r| r.id))

    Ok(None)
}

/// Upsert passport record and return ID
pub async fn upsert_passport_record(
    _tx: &mut Transaction<'_, Postgres>,
    _address: &str,
    _scorer_id: i64,
) -> Result<i64, DatabaseError> {
    // TODO: Implement after SQLX prepare
    // let result = sqlx::query!(
    //     r#"
    //     INSERT INTO registry_passport (address, community_id)
    //     VALUES ($1, $2)
    //     ON CONFLICT (address, community_id)
    //     DO UPDATE SET address = EXCLUDED.address
    //     RETURNING id
    //     "#,
    //     address,
    //     scorer_id
    // )
    // .fetch_one(&mut **tx)
    // .await?;
    //
    // Ok(result.id)

    Ok(1) // Stub return
}

/// Get score by passport_id
pub async fn get_score(
    _pool: &PgPool,
    _passport_id: i64,
) -> Result<Option<i64>, DatabaseError> {
    // TODO: Implement after SQLX prepare
    // let result = sqlx::query!(
    //     r#"
    //     SELECT id FROM registry_score
    //     WHERE passport_id = $1
    //     "#,
    //     passport_id
    // )
    // .fetch_optional(pool)
    // .await?;
    //
    // Ok(result.map(|r| r.id))

    Ok(None)
}

/// Upsert score record
pub async fn upsert_score_record(
    _tx: &mut Transaction<'_, Postgres>,
    _passport_id: i64,
    _score: rust_decimal::Decimal,
    _threshold: rust_decimal::Decimal,
    _stamps: serde_json::Value,
    _stamp_scores: serde_json::Value,
    _evidence: serde_json::Value,
    _expiration_date: Option<chrono::DateTime<chrono::Utc>>,
) -> Result<i64, DatabaseError> {
    // TODO: Implement after SQLX prepare
    // let result = sqlx::query!(
    //     r#"
    //     INSERT INTO registry_score (
    //         passport_id, score, last_score_timestamp, status,
    //         evidence, stamp_scores, stamps, expiration_date, error
    //     )
    //     VALUES ($1, $2, NOW(), 'DONE', $3, $4, $5, $6, NULL)
    //     ON CONFLICT (passport_id)
    //     DO UPDATE SET
    //         score = EXCLUDED.score,
    //         last_score_timestamp = EXCLUDED.last_score_timestamp,
    //         status = EXCLUDED.status,
    //         evidence = EXCLUDED.evidence,
    //         stamp_scores = EXCLUDED.stamp_scores,
    //         stamps = EXCLUDED.stamps,
    //         expiration_date = EXCLUDED.expiration_date,
    //         error = EXCLUDED.error
    //     RETURNING id
    //     "#,
    //     passport_id,
    //     score,
    //     evidence,
    //     stamp_scores,
    //     stamps,
    //     expiration_date
    // )
    // .fetch_one(&mut **tx)
    // .await?;
    //
    // Ok(result.id)

    Ok(1) // Stub return
}